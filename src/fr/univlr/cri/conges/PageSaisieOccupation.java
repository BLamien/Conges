package fr.univlr.cri.conges;
// Generated by the WOLips Core at Fri Jul 30 15:58:09 CEST 2004

import com.webobjects.appserver.WOComponent;
import com.webobjects.appserver.WOContext;
import com.webobjects.eocontrol.EOQualifier;
import com.webobjects.eocontrol.EOSortOrdering;
import com.webobjects.foundation.NSArray;
import com.webobjects.foundation.NSMutableArray;
import com.webobjects.foundation.NSTimestamp;

import fr.univlr.cri.conges.constantes.ConstsOccupation;
import fr.univlr.cri.conges.databus.CngOccupationBus;
import fr.univlr.cri.conges.eos.modele.planning.EOOccupation;
import fr.univlr.cri.conges.eos.modele.planning.EOTypeOccupation;
import fr.univlr.cri.conges.eos.modele.planning.I_ClasseMetierNotificationParametre;
import fr.univlr.cri.conges.objects.Parametre;
import fr.univlr.cri.conges.objects.Planning;
import fr.univlr.cri.conges.utils.TimeCtrl;
import fr.univlr.cri.util.StringCtrl;
import fr.univlr.cri.webapp.CRIDataBus;

public class PageSaisieOccupation 
	extends YCRIWebPage
		implements ConstsOccupation, I_ClasseMetierNotificationParametre {

  // variables entrantes
	public Planning lePlanning;
	public NSArray lesTypesOccupations;
	public Object unTypeOccupation;
	public Object leTypeOccupationSelectionne;
	public NSTimestamp dateDebut;
	public NSArray AMPM;
	public String dateDebutAMPM;
	public String dateDebutAMPMSelection;
	public NSTimestamp dateFin;
	public String dateFinAMPM;
	public String dateFinAMPMSelection;
	public String leMotif;
	public boolean errMotif;
  // occupation journali�re : heure de d�but et heure de fin
	public String hDebut;
	public String hFin;
	public Number laValeur;
  // erreur
	public String txtErreur;
  
  // afficher l'edition papier pour toute demande de conge
  private static boolean isShowDemandeCongesPapier;
	
  public PageSaisieOccupation(WOContext context) {
    super(context);
  }
  
	/**
	 * @see I_ClasseMetierNotifiableParametre
	 */
	public static void initStaticField(Parametre parametre) {
		if (parametre == Parametre.PARAM_SHOW_DEMANDE_CONGES_PAPIER) {
			isShowDemandeCongesPapier = parametre.getParamValueBoolean().booleanValue();
		}
  }

//  public void appendToResponse(WOResponse aResponse, WOContext aContext) {
//    super.appendToResponse(aResponse, aContext);
//    addHTMLBinding(aResponse, "onLoad", "'if (opener && opener.blockEvents) opener.blockEvents()'", TAG_OPEN_BODY);
//  }
  
  public void reset() {
    super.reset();
    leTypeOccupationSelectionne = null;
    dateDebut = null;
    dateDebutAMPMSelection = null;
    dateFin = null;
    dateFinAMPMSelection = null;
    leMotif = null;
    laValeur = null;
    txtErreur = null;
  }

  public boolean hasErreur() {
    return !StringCtrl.isEmpty(txtErreur);
  }

  public void externeSetLePlanning(Planning value) {
    lePlanning = value;
  }

  public WOComponent choisirUnTypeOccupation() {

    return null;
  }

  public WOComponent saisirUneOccupation() {
    return null;
  }

  // TODO raz le cache des plannings modifies (ceux de la session)
  public WOComponent valider() throws Throwable {
    PageTransactionOK nextPage = null;

    // test si le motif n'est pas trop long (max 100c)
    if (leMotif != null && leMotif.length() > 100) {
      txtErreur = "Le motif ne doit pas exc&eacute;der 100 caract&egrave;res !";
      return null;
    }

    if (leTypeOccupationSelectionne != null && ((EOTypeOccupation)leTypeOccupationSelectionne).isOccupationMinute()) {
      // recuperation de l'heure de debut et l'heure de fin pour les coller a la date de debut 0:00
      if (!StringCtrl.isEmpty(hDebut))
        dateDebut = TimeCtrl.dateToMinuit(dateDebut).timestampByAddingGregorianUnits(
            0, 0, 0, TimeCtrl.getHeuresFromString(hDebut), TimeCtrl.getMinutesFromString(hDebut), 0);
      if (!StringCtrl.isEmpty(hFin))
        dateFin = TimeCtrl.dateToMinuit(dateDebut).timestampByAddingGregorianUnits(
            0, 0, 0, TimeCtrl.getHeuresFromString(hFin), TimeCtrl.getMinutesFromString(hFin), 0);
    } else {
      // Recuperation de la date de debut et de la date de fin de l'occupation
      if (dateDebutAMPMSelection.equals(OCC_APREM))
        dateDebut = dateDebut.timestampByAddingGregorianUnits(0, 0, 0, 12, 0, 0);
      if (dateFinAMPMSelection.equals(OCC_APREM))
        dateFin = dateFin.timestampByAddingGregorianUnits(0, 0, 0, 12, 0, 0);
    }

    // determiner tous les plannings a impacter par rapport au dates de cette occupation
    NSArray planningsToChange = new NSArray();
    if (dateDebut != null && dateFin != null) {
      planningsToChange = occupationBus().addOccupation(
      		edc, laSession, lePlanning, (EOTypeOccupation) leTypeOccupationSelectionne, 
          dateDebut, dateFin, leMotif);
      if (planningsToChange == null) {
        txtErreur = occupationBus().getErrorMessage();
        occupationBus().setErrorMessage(null);
        return null;
      }
    }
    
    // 

    // pas de planning a impacter -> erreur
    if (planningsToChange != null && planningsToChange.count() == 0 && StringCtrl.isEmpty(txtErreur)) {
      txtErreur = "Vous n'avez pas de planning pour cette periode ...";
      return null;
    }
    
    if (planningsToChange != null && planningsToChange.count() > 0) {
      nextPage = (PageTransactionOK) laSession.getSavedPageWithName(PageTransactionOK.class.getName());
      // recharger integralement les autres plannings impactes
      NSMutableArray others = new NSMutableArray(planningsToChange);
      others.removeObject(lePlanning);
      for (int i = 0; i < others.count(); i++)
        laSession.clearCachePlanning((Planning) others.objectAtIndex(i));
      // lancer le recalcul conges + occupations pour le planning actuel
      lePlanning.calculerOccupationChronologiques();
      laSession.setPlanningForce(lePlanning);
      
      // si l'application autorise les editions de demande papier
      // alors on va passer l'enregistrement de la nouvelle occupation
      // a la page suivante
      if (isShowDemandeCongesPapier) {
      	
      	// trouver l'enregistrement EOOccupation associe a ce planning
      	EOOccupation recOccupation = null;
      	
      	String motif = (StringCtrl.isEmpty(leMotif) ? "" : leMotif);
       	
      	NSArray result = EOQualifier.filteredArrayWithQualifier(
      			lePlanning.absences(), CRIDataBus.newCondition(
      					"type=%@ and dateDebut=%@ and dateFin=%@ and motif=%@", 
      					new NSArray(new Object[]{
      							((EOTypeOccupation)leTypeOccupationSelectionne).libelle(), dateDebut, dateFin, motif})));

      	if (result.count() > 0) {
      		recOccupation = (EOOccupation) result.lastObject();
      	}
      	
      	nextPage.setRecOccupationAImprimer(recOccupation);
        
      }
      
      reset();
    }

    return nextPage;
  }

  // TODO typer le type d'occupation a partir de l'absence
  /**
   * boolean determinant le type d'occupation (norm ou journ)
   */
  public boolean isOccupationMinute() {
    // on determine le type d'occupation ("normale" ou journaliere)
    if (isUnTypeOccupationSelectionne())
      return ((EOTypeOccupation)leTypeOccupationSelectionne).isOccupationMinute();
    else
      return false;
  }

  public WOComponent annuler() {
  	PageTransactionOK nextPage = (PageTransactionOK) laSession.getSavedPageWithName(PageTransactionOK.class.getName());
  	nextPage.setRecOccupationAImprimer(null);
    return nextPage;
  }

  /**
   * @return
   */
  public NSArray getAMPM() {
    if (AMPM == null)
      AMPM = new NSArray(new String[] { OCC_MATIN, OCC_APREM });
    return AMPM;
  }

  /**
   * toutes les types d'ooccupation qu'il peut poser
   * on affiche par cat�gorie
   */
  public NSArray getLesTypesOccupations() {
    if (lesTypesOccupations == null) {
      lesTypesOccupations = new NSArray();
      //NSArray records = EOUtilities.objectsWithFetchSpecificationAndBindings(edc, EOTypeOccupation.ENTITY_NAME, "OccupationsEditables", null);
      NSArray records = EOTypeOccupation.findTypesOccupationsEditablesInContext(edc);
      
      records = EOSortOrdering.sortedArrayUsingKeyOrderArray(records, EOTypeOccupation.ARRAY_SORT);
      lesTypesOccupations = lesTypesOccupations.arrayByAddingObject("--- Occupations a la 1/2 journee ---");
      lesTypesOccupations = lesTypesOccupations.arrayByAddingObjectsFromArray(
      		EOTypeOccupation.filterTypeOccupation(records, false, false));
      lesTypesOccupations = lesTypesOccupations.arrayByAddingObject("");
      lesTypesOccupations = lesTypesOccupations.arrayByAddingObject("--- Occupations a la minute ---");
      lesTypesOccupations = lesTypesOccupations.arrayByAddingObjectsFromArray(
      		EOTypeOccupation.filterTypeOccupation(records, true, false));
      lesTypesOccupations = lesTypesOccupations.arrayByAddingObject("");
      lesTypesOccupations = lesTypesOccupations.arrayByAddingObject("--- Occupations a la 1/2 journee (DRH) ---");
      lesTypesOccupations = lesTypesOccupations.arrayByAddingObjectsFromArray(
      		EOTypeOccupation.filterTypeOccupation(records, false, true));
      lesTypesOccupations = lesTypesOccupations.arrayByAddingObject("");
      lesTypesOccupations = lesTypesOccupations.arrayByAddingObject("--- Occupations a la minute (DRH) ---");
      lesTypesOccupations = lesTypesOccupations.arrayByAddingObjectsFromArray(
      		EOTypeOccupation.filterTypeOccupation(records, true, true));

      // si son cet est vide, on enleve le type conges pour cet
      //TODO masquer si pas de minutes en CET
      if (lePlanning.toCET() == null) {
        NSMutableArray lesTypesOccupationsMutable = new NSMutableArray(lesTypesOccupations);
        lesTypesOccupationsMutable.removeIdenticalObject(laSession.typeCongesCET());
        lesTypesOccupations = lesTypesOccupationsMutable.immutableClone();
      }

      // si pas de decharge syndicale, on les enleve
      if (!lePlanning.affectationAnnuelle().isDechargeSyndicale()) {
        NSMutableArray lesTypesOccupationsMutable = new NSMutableArray(lesTypesOccupations);
        lesTypesOccupationsMutable.removeIdenticalObject(laSession.typeDechargeSyndicaleJour());
        lesTypesOccupationsMutable.removeIdenticalObject(laSession.typeDechargeSyndicaleMinute());
        lesTypesOccupations = lesTypesOccupationsMutable.immutableClone();
      }
    }
    
    
    return lesTypesOccupations;
  }

  public void setDateDebut(NSTimestamp date) {
    dateDebut = date;
  }

  public void setDateFin(NSTimestamp date) {
    dateFin = date;
  }

  public void setDateDebutAMPMSelection(String string) {
    dateDebutAMPMSelection = string;
  }

  public void setDateFinAMPMSelection(String string) {
    dateFinAMPMSelection = string;
  }

  public void setLeTypeOccupationSelectionne(Object value) {
    leTypeOccupationSelectionne = value;
  }

  public boolean isUnTypeOccupationSelectionne() {
    return leTypeOccupationSelectionne != null && leTypeOccupationSelectionne instanceof EOTypeOccupation;
  }

  public String unTypeOccupationDisplay() {
    String display = "";
    if (unTypeOccupation != null && unTypeOccupation instanceof EOTypeOccupation) {
      display = ((EOTypeOccupation)unTypeOccupation).libelle();
    } else {
      display = (String) unTypeOccupation;
    }
    return display;
  }
  
  public boolean isOccupationPrevisionnelle() {
    boolean isOccupationPrevisionnelle = false;
    if (lePlanning.isPPrev()) {
      isOccupationPrevisionnelle = true;
      leTypeOccupationSelectionne = laSession.typeCongeAnnuel();
    }
    return isOccupationPrevisionnelle;
  }
  
  // les bus de donnees
  
  public CngOccupationBus occupationBus() {
    return laSession.cngDataCenter().occupationBus();
  }
}