package fr.univlr.cri.conges;
// Generated by the WOLips Core at Fri Aug 27 09:03:04 CEST 2004

import java.util.Calendar;
import java.util.GregorianCalendar;

import com.webobjects.appserver.WOComponent;
import com.webobjects.appserver.WOContext;
import com.webobjects.eocontrol.EOQualifier;
import com.webobjects.foundation.NSArray;
import com.webobjects.foundation.NSMutableArray;
import com.webobjects.foundation.NSTimestamp;

import fr.univlr.cri.conges.constantes.ConstsOccupation;
import fr.univlr.cri.conges.databus.CngOccupationBus;
import fr.univlr.cri.conges.eos.modele.planning.EOAffectationAnnuelle;
import fr.univlr.cri.conges.eos.modele.planning.EOOccupation;
import fr.univlr.cri.conges.objects.I_Absence;
import fr.univlr.cri.conges.objects.Planning;
import fr.univlr.cri.conges.utils.DateCtrlConges;
import fr.univlr.cri.conges.utils.TimeCtrl;
import fr.univlr.cri.util.StringCtrl;
import fr.univlr.cri.webapp.CRIDataBus;

public class PageDetailAbsence 
	extends A_PagePrintDemCongePapier  {

  // variables entrantes
	public Planning lePlanning;
  public I_Absence uneAbsence;
  public NSTimestamp dateDebut;
  public NSArray AMPM;
  public String dateDebutAMPM;
  public String dateDebutAMPMSelection;
  public NSTimestamp dateFin;
  public String dateFinAMPM;
  public String dateFinAMPMSelection;
  public String motif;

  // erreur
  public String txtErreur;

  // occupation journalière : heure de début et heure de fin
  public String hDebut;
  public String hFin;

  public PageDetailAbsence(WOContext context) {
    super(context);
  }
  
  /**
   * Enregistrement <code>EOOccupation</code> a utiliser
   * lors de l'edition de la demande papier
   */
	public EOOccupation recOccupationAImprimer() {
		EOOccupation record = null;
		if (uneAbsence() instanceof EOOccupation) {
			record = (EOOccupation) uneAbsence();
		}
		return record;
	}

	//

  public void reset() {
    super.reset();
    dateDebut = null;
    dateFin = null;
    dateDebutAMPM = null;
    dateDebutAMPMSelection = null;
    dateFinAMPM = null;
    dateFinAMPMSelection = null;
    motif = null;
    txtErreur = null;
  }

  public void externeSetLePlanning(Planning value) {
    lePlanning = value;
  }

  public boolean hasErreur() {
    return txtErreur != null;
  }

  public String onUnLoad() {
    String onUnLoad = "";

    return onUnLoad;
  }

  /**
   * @param dateDebutTS
   */
  public void setDateDebut(NSTimestamp dateDebutTS) {
    dateDebut = dateDebutTS;
  }

  /**
   * @return
   */
  public NSTimestamp dateDebut() {
    return dateDebut;
  }

  /**
   * @return
   */
  public NSTimestamp dateFin() {
    return dateFin;
  }

  /**
   * @param timestamp
   */
  public void setDateFin(NSTimestamp timestamp) {
    dateFin = timestamp;
  }

  /**
   * @return
   */
  public NSArray AMPM() {
    if (AMPM == null) {
      AMPM = new NSArray(new String[] { ConstsOccupation.OCC_MATIN, ConstsOccupation.OCC_APREM });
    }

    return AMPM;
  }

  /**
   * @return
   */
  public String dateDebutAMPM() {
    return dateDebutAMPM;
  }

  /**
   * @return
   */
  public String dateDebutAMPMSelection() {
    return dateDebutAMPMSelection;
  }

  /**
   * @return
   */
  public String dateFinAMPM() {
    return dateFinAMPM;
  }

  /**
   * @return
   */
  public String dateFinAMPMSelection() {
    return dateFinAMPMSelection;
  }

  /**
   * @return
   */
  public I_Absence uneAbsence() {
    return uneAbsence;
  }

  /**
   * @param absence
   */
  public void setUneAbsence(I_Absence absence) {
    NSTimestamp dateDebutTS = absence.dateDebut();
    NSTimestamp dateFinTS = absence.dateFin();
    GregorianCalendar dateDebutGC = new GregorianCalendar();
    GregorianCalendar dateFinGC = new GregorianCalendar();

    uneAbsence = absence;
    setDateDebut(dateDebutTS);
    setDateFin(dateFinTS);
    dateDebutGC.setTime(dateDebutTS);
    dateFinGC.setTime(dateFinTS);
    if (!uneAbsence().isOccupationMinute()) {
      if (dateDebutGC.get(GregorianCalendar.AM_PM) == GregorianCalendar.AM) {
        dateDebutAMPM = ConstsOccupation.OCC_MATIN;
      } else {
        dateDebutAMPM = ConstsOccupation.OCC_APREM;
      }
      dateDebutAMPMSelection = dateDebutAMPM;
      if (dateFinGC.get(GregorianCalendar.AM_PM) == GregorianCalendar.AM) {
        dateFinAMPM = ConstsOccupation.OCC_MATIN;
      } else {
        dateFinAMPM = ConstsOccupation.OCC_APREM;
      }
      dateFinAMPMSelection = dateFinAMPM;
    } else {
      // recuperation des heures
      hDebut = dateDebutGC.get(Calendar.HOUR_OF_DAY) + ":" + (dateDebutGC.get(Calendar.MINUTE) < 10 ? "0" : "") + dateDebutGC.get(Calendar.MINUTE);
      hFin = dateFinGC.get(Calendar.HOUR_OF_DAY) + ":" + (dateFinGC.get(Calendar.MINUTE) < 10 ? "0" : "") + dateFinGC.get(Calendar.MINUTE);
    }

    // recup du motif
    try {
      motif = ((EOOccupation) absence).motif();
    } catch (Exception e) {
    }
  }

  public WOComponent supprimer() throws Throwable {
    boolean transactionOK = false;
    PageTransactionOK nextPage = null;
    // Planning lePlanning = laSession.lePlanningSelectionne();
    // si status = en cours de validation suppression directe et reimputation
    // sinon passer en status en cours de suppression et alerte de suppression
    // A la validation reimputer le compte courant et passer en status supprimee
    if (!uneAbsence().isFermeture()) {
      EOOccupation absence = (EOOccupation) uneAbsence();
      transactionOK = occupationBus().deleteOccupation(edc, laSession, lePlanning, absence);
      doReloadStuff();
    } else {
      txtErreur = "Vous ne pouvez pas supprimer une fermeture ...";
    }
    
    if (transactionOK) {
      nextPage = (PageTransactionOK) laSession.getSavedPageWithName(PageTransactionOK.class.getName());
      nextPage.setRecOccupationAImprimer(null);
    }
    else {
      txtErreur = occupationBus().getErrorMessage();
      occupationBus().setErrorMessage(null);
    }
    
    return nextPage;
  }

  public WOComponent modifier() throws Throwable {
  	PageTransactionOK nextPage = null;
    boolean transactionOK = false;
    if (uneAbsence().isOccupationMinute()) {
      // recuperation de l'heure de debut et l'heure de fin pour les coller a la date de debut 0:00
      if (!StringCtrl.isEmpty(hDebut)) {
        dateDebut = TimeCtrl.dateToMinuit(dateDebut).timestampByAddingGregorianUnits(0, 0, 0, TimeCtrl.getHeuresFromString(hDebut),
            TimeCtrl.getMinutesFromString(hDebut), 0);
      }
      if (!StringCtrl.isEmpty(hFin)) {
        dateFin = TimeCtrl.dateToMinuit(dateDebut).timestampByAddingGregorianUnits(0, 0, 0, TimeCtrl.getHeuresFromString(hFin),
            TimeCtrl.getMinutesFromString(hFin), 0);
      }

    } else {
      // Recuperation de la date de debut et de la date de fin de l'occupation
      if (dateDebutAMPMSelection.equals(ConstsOccupation.OCC_APREM)) {
        dateDebut = dateDebut.timestampByAddingGregorianUnits(0, 0, 0, 12, 0, 0);
      }
      if (dateFinAMPMSelection.equals(ConstsOccupation.OCC_APREM)) {
        dateFin = dateFin.timestampByAddingGregorianUnits(0, 0, 0, 12, 0, 0);
      }
    }

    transactionOK = occupationBus().updateOccupation(edc, laSession, lePlanning, (EOOccupation) uneAbsence, dateDebut, dateFin, motif);

    if (transactionOK) {
      doReloadStuff();
      nextPage = (PageTransactionOK) laSession.getSavedPageWithName(PageTransactionOK.class.getName());
     
      // si l'application autorise les editions de demande papier
      // alors on va passer l'enregistrement de la nouvelle occupation
      // a la page suivante
      if (isShowDemandeCongesPapier) {
      	
      	// trouver l'enregistrement EOOccupation associe a ce planning
      	EOOccupation recOccupation = null;
      	
      	String newMotif = (StringCtrl.isEmpty(motif) ? "" : motif);
       	
      	NSArray result = EOQualifier.filteredArrayWithQualifier(
      			lePlanning.absences(), CRIDataBus.newCondition(
      					"type=%@ and dateDebut=%@ and dateFin=%@ and motif=%@", 
      					new NSArray(new Object[]{uneAbsence.type(), dateDebut, dateFin, newMotif})));

      	if (result.count() > 0) {
      		recOccupation = (EOOccupation) result.lastObject();
      	}
      	
      	nextPage.setRecOccupationAImprimer(recOccupation);
        
      }
      nextPage.setRecOccupationAImprimer((EOOccupation) uneAbsence());
    } else {
      txtErreur = occupationBus().getErrorMessage();
      occupationBus().setErrorMessage(null);
    }

    return nextPage;
  }

  public WOComponent annuler() {
    WOComponent nextPage = null;

    return nextPage;
  }

  /**
   * Methode qui se charge de faire le rechargement des donnees
   * suite la modification d'une absence
   * @throws Throwable 
   *
   */
  private void doReloadStuff() throws Throwable {
    // recup des plannings correspondants
    NSArray planningsToChange = new NSArray();
    EOQualifier qual = EOQualifier.qualifierWithQualifierFormat(
        "(dateDebutAnnee>=%@ AND dateDebutAnnee<=%@) OR" +
        "(dateFinAnnee>=%@ AND dateFinAnnee<=%@) OR" +
        "(dateDebutAnnee<=%@ AND dateFinAnnee>=%@) OR" +
        "(dateDebutAnnee>=%@ AND dateFinAnnee<=%@)",
        new NSArray( new NSTimestamp[] { 
            dateDebut, dateFin, dateDebut, dateFin, dateDebut, dateFin, dateDebut, dateFin, }));
    NSArray affectationsAnnuelles = EOQualifier.filteredArrayWithQualifier(laSession.affAnnsPerso(), qual);
    // on sauvegarde la selection de la session
    EOAffectationAnnuelle backupSelectionAffSAnnPerso = laSession.selectedAffAnnPerso();
    for (int i = 0; i < affectationsAnnuelles.count(); i++) {
      // on fixe 1 par 1 l'aff annuelle de la session pour recuperer tous les plannings, sans forcement tout recalculer
      laSession.setSelectedAffAnnPerso((EOAffectationAnnuelle) affectationsAnnuelles.objectAtIndex(i));
      planningsToChange = planningsToChange.arrayByAddingObject(laSession.getLePlanningSelectionne());
    }
    // retribution de la selection
    laSession.setSelectedAffAnnPerso(backupSelectionAffSAnnPerso);

    
    // lancer le recalcul conges + occupations
    // recharger integralement les autres plannings impactes
    NSMutableArray others = new NSMutableArray(planningsToChange);
    others.removeObject(lePlanning);
    for (int i = 0; i < others.count(); i++)
      laSession.clearCachePlanning((Planning) others.objectAtIndex(i));
    // lancer le recalcul conges + occupations pour le planning actuel
    lePlanning.calculerOccupationChronologiques();
    laSession.setPlanningForce(lePlanning);   
  }
  
  /**
   * On ne peut modifier que les conges normaux en cours 
   * de validation sur l'affectation annuelle courante
   * 
   * L'administrateur global peut tout faire
   */
  // TODO gestion de la suppression de fermeture annuelle
  public boolean isAbsenceModifiable() {
    boolean isAbsenceModifiable = false;
    if (!lePlanning.isDisabled() &&
    		!isFermetureAnnuelle() && 
    		!isCongeLegal() && 
    		uneAbsence.affectationAnnuelle() == lePlanning.affectationAnnuelle()) {
      if (((EOOccupation) uneAbsence).status().equals(ConstsOccupation.CODE_EN_COURS_DE_VALIDATION)) {
        isAbsenceModifiable = true;
      }
    }
    return isAbsenceModifiable;
  }

  /**
   * on ne peut pas virer les fermetures annuelles, les congés légaux et les 
   * absences sur d'autres affectations annuelles, les absences sur planning
   * disabled et les absences en cours de suppression (visee ou pas)
   * 
   * L'administrateur global peut tout faire
   */
  public boolean isAbsenceSupprimable() {
    boolean isAbsenceSupprimable = true;
    if (lePlanning.isDisabled() ||
    		isFermetureAnnuelle() || 
    		uneAbsence.affectationAnnuelle() != lePlanning.affectationAnnuelle()|| 
    		uneAbsence.isCongeLegal() || 
    		((EOOccupation) uneAbsence).status().equals(ConstsOccupation.CODE_EN_COURS_DE_SUPPRESSION) ||
    		((EOOccupation) uneAbsence).status().equals(ConstsOccupation.CODE_EN_COURS_DE_SUPPRESSION_VISEE)) {
      isAbsenceSupprimable = false;
    }
    return isAbsenceSupprimable;
  }

  public boolean isFermetureAnnuelle() {
    return uneAbsence.isFermeture();
  }
  
  public boolean isCongeLegal() {
  	return uneAbsence.isCongeLegal();
  }
  
  public boolean isAbsenceSaisieParRh() {
  	return isFermetureAnnuelle() || isCongeLegal();
  }

  public boolean isDechargeSyndicale() {
    return !isFermetureAnnuelle() && !isCongeLegal() && ((EOOccupation) uneAbsence).typeOccupation().isDechargeSyndicale();
  }
  
  public boolean isAbsenceCET() {
  	return !isFermetureAnnuelle() && !isCongeLegal() && ((EOOccupation) uneAbsence).typeOccupation().isAbsenceCET();
  }

  public boolean isAbsenceEnCoursDeSuppression() {
  	return !isFermetureAnnuelle() && !isCongeLegal() && ((EOOccupation) uneAbsence).isEnCoursDeSuppression();
  }

  public boolean isAbsenceEnCoursDeValidation() {
  	return !isFermetureAnnuelle() && !isCongeLegal() && ((EOOccupation) uneAbsence).isEnCoursDeValidation();
  }
  
  /**
   * l'interface est verrouillée si pas modifiable
   * 
   * @return
   */
  public boolean disabledElements() {
    return !isAbsenceModifiable();
  }

  public String leDebitConges() {
    String leDebitConges = "";
    leDebitConges = DateCtrlConges.to_duree(uneAbsence().leDebitConges());
    return leDebitConges;
  }

  public String leDebitReliquat() {
    String leDebitReliquat = "";
    leDebitReliquat = DateCtrlConges.to_duree(uneAbsence().leDebitReliquats());
    return leDebitReliquat;
  }

  public String leDebitDechargeSyndicale() {
    String leDebitDechargeSyndicale = "";
    leDebitDechargeSyndicale = DateCtrlConges.to_duree(uneAbsence().leDebitDechargeSyndicale());
    return leDebitDechargeSyndicale;
  }

  public String leDebitCET() {
    String leDebitCET = "";
    leDebitCET = DateCtrlConges.to_duree(uneAbsence().leDebitCET());
    return leDebitCET;
  }

  /**
   * si l'absence n'est que d'1/2 journee, afficher le message 
   * "pour saisir l'autre demi journée en congés, passer par la fiche rose"
   */
  public boolean isDemiJournee() {
    return uneAbsence().dateDebut().equals(uneAbsence().dateFin());
  }
  
  /**
   * 
   */
  public boolean hasValideur() {
    return uneAbsence().valideur() != null;
  }
  
  /**
   * 
   */
  public boolean hasViseur() {
    return uneAbsence().viseur() != null;
  }
  
  /**
   * 
   */
  public boolean hasDelegue() {
    return uneAbsence().delegue() != null;
  }
  

  // 

  /**
   * Le libelle du bouton de suppression change selon
   * l'etat de validation de l'absence
   */
  public String getBtnSupprimerLabel() {
  	String label = "Supprimer";
  	if (lePlanning.isPReel() && !((EOOccupation) uneAbsence).isSupprimableSansValidation()) {
  		label = "Faire une demande de suppression";
  	}
  	return label;
  }
  
  
   
  // raccourcis bus de donnees
  
  private CngOccupationBus occupationBus() {
    return laSession.cngDataCenter().occupationBus();
  }

  
  
  
}