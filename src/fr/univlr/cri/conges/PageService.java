package fr.univlr.cri.conges;

// Generated by the WOLips Core at Tue Sep 14 11:54:29 CEST 2004

import java.util.Calendar;
import java.util.GregorianCalendar;

import com.webobjects.appserver.WOComponent;
import com.webobjects.appserver.WOContext;
import com.webobjects.appserver.WODisplayGroup;
import com.webobjects.appserver.WORequest;
import com.webobjects.appserver.WOResponse;
import com.webobjects.eoaccess.EOUtilities;
import com.webobjects.eocontrol.EOEditingContext;
import com.webobjects.eocontrol.EOQualifier;
import com.webobjects.eocontrol.EOSortOrdering;
import com.webobjects.foundation.NSArray;
import com.webobjects.foundation.NSDictionary;
import com.webobjects.foundation.NSMutableArray;
import com.webobjects.foundation.NSMutableDictionary;
import com.webobjects.foundation.NSTimestamp;

import fr.univlr.cri.conges.constantes.ConstsOccupation;
import fr.univlr.cri.conges.constantes.ConstsPlanning;
import fr.univlr.cri.conges.eos.modele.conges.EOStructureAutorisee;
import fr.univlr.cri.conges.eos.modele.grhum.EOStructure;
import fr.univlr.cri.conges.eos.modele.planning.EOAffectationAnnuelle;
import fr.univlr.cri.conges.eos.modele.planning.EOHoraire;
import fr.univlr.cri.conges.eos.modele.planning.EOPlanningHebdomadaire;
import fr.univlr.cri.conges.eos.modele.planning.I_ClasseMetierNotificationParametre;
import fr.univlr.cri.conges.objects.HoraireJournalier;
import fr.univlr.cri.conges.objects.Parametre;
import fr.univlr.cri.conges.objects.Planning;
import fr.univlr.cri.conges.objects.Responsabilite;
import fr.univlr.cri.conges.print.CngPdfBoxCtrl;
import fr.univlr.cri.conges.print.ConstsPrint;
import fr.univlr.cri.conges.print.PrintCSV;
import fr.univlr.cri.conges.print.PrintHoraires;
import fr.univlr.cri.conges.print.PrintServiceDemiJournees;
import fr.univlr.cri.conges.utils.DateCtrlConges;
import fr.univlr.cri.conges.utils.TimeCtrl;
import fr.univlr.cri.util.ArrayCtrl;
import fr.univlr.cri.util.StringCtrl;
import fr.univlr.cri.util.wo5.DateCtrl;
import fr.univlr.cri.webapp.CRIDataBus;
import fr.univlr.cri.webapp.LRLog;

public class PageService
		extends YCRIWebPage
		implements I_ClasseMetierNotificationParametre {

	private String typePlanningEnCours; // type de planning en cours
	public int indexUneAffectationAnnuelleDuService;
	public EOAffectationAnnuelle uneAffectationAnnuelleDuService;
	public String unePresenceHoraire;
	private NSTimestamp leMoisSelectionne;
	public NSTimestamp leMois, unMois = null;
	private NSArray lesMois;
	public NSArray lesJoursLibelle = new NSArray(new String[] { "L", "M", "M", "J", "V", "S", "D" });
	public NSArray lesJours = null;
	public NSTimestamp lesJoursItem = null;

	private int minutesEchelle, minutesEchelleInitales;
	private final static int MINUTES_DEBUT_JOURNEE_COMPLETE = 0;
	private final static int MINUTES_DEBUT_JOURNEE_PARTIELLE = 7 * 60;

	public boolean isVisuHoraire = false;
	private NSMutableArray lesSemainesDeLAnnee;
	public NSTimestamp uneSemaineDeLAnnee;
	public NSTimestamp laSemaineDeLAnneeSelectionnee;
	public NSArray lesJoursLibelleLong = HoraireJournalier.libellesJours;
	public String unJourLibelleLong;
	public int indexJourEnCours;
	public boolean voirJourneeComplete;

	public int nbItemEchelle, nbItemRegle, tailleGraph;
	private final static int MAX_TAILLE_GRAPH = 1440;

	// boolean pour savoir si on est le matin ou l'apres midi
	private boolean isAM;

	// faut-il voir en plus le planning previsionnel
	public boolean showPrevisionnel = false;

	// popup des annees univ
	private NSArray listAnneeUniv;
	public String itemAnneeUniv;
	// l'annee universitaire en cours
	public String selectedAnneeUniv;
	private String prevSelectedAnneeUniv;
	private NSTimestamp selectedAnneeUnivTS;

	// le cache contenant le presentiel des agents sur le mois en cours
	// (problemes dus au WORepetition qui se declenchent avant le
	// appendToResponse() )
	private NSMutableDictionary dicoPresence;

	/** mode filtrage actif */
	private final static int MODE_FILTER_APPLIED = 0;
	/** mode filtrage inactif */
	private final static int MODE_FILTER_RELEASED = 1;
	/** indique si oui ou non on affiche une liste restreinte de personnes */
	private int modeFilter = MODE_FILTER_RELEASED;
	/** les affectation annuelles selectionnee */
	private NSArray recsFilteredAffAnns;

	// gestion de l'affichage des plannings sur tout le service
	// ou sur toute la composante (service par defaut)
	public final int RADIO_ID_STRUCTURE_SERVICE = 0;
	public final int RADIO_ID_STRUCTURE_COMPOSANTE = 1;
	public final int RADIO_ID_PLANNINGS_CONSULTABLES_PAR_MOI = 2;
	private int radioIdStructure = RADIO_ID_STRUCTURE_SERVICE;

	private WODisplayGroup dgAffectationAnnuelle;

	public PageService(WOContext context) {
		super(context);
		initComponent();
	}

	/**
   * 
   */
	private void initComponent() {
		// selection par defaut de l'annee universitaire en cours
		setSelectedAnneeUniv(DateCtrlConges.anneeUnivForDate(laSession.dateRef()));
		// on fixe le jour de la semaine a celui actuel
		GregorianCalendar calendar = new GregorianCalendar();
		calendar.setTime(laSession.dateRef());
		indexJourEnCours = calendar.get(Calendar.DAY_OF_WEEK);
		if (indexJourEnCours < 2)
			indexJourEnCours += 5;
		else
			indexJourEnCours -= 2;
		resetDgAffectationAnnuelle();
	}

	/**
   * 
   */
	private void resetDgAffectationAnnuelle() {
		dgAffectationAnnuelle = null;
	}

	/**
	 * initialisation de la liste des annees universitaires
	 */
	public NSArray listAnneeUniv() {
		if (listAnneeUniv == null) {
			listAnneeUniv = new NSArray();
			// liste des annees ou il y a eu des services autorises
			listAnneeUniv = EOStructureAutorisee.findAllDebutAnneeUnivStringInContext(edc);
			listAnneeUniv = listAnneeUniv.arrayByAddingObject(DateCtrlConges.anneeUnivForDate(laSession.dateRef()));
			listAnneeUniv = listAnneeUniv.arrayByAddingObject(DateCtrlConges.anneeUnivForDate(
					laSession.dateRef().timestampByAddingGregorianUnits(1, 0, 0, 0, 0, 0)));
			// on vire les doubles au cas ou
			listAnneeUniv = ArrayCtrl.removeDoublons(listAnneeUniv);
		}
		return listAnneeUniv;
	}

	/**
	 * Lors du changement de l'annee universitaire, on reinitialise la liste des
	 * affectations annuelles et des mois.
	 */
	public void setSelectedAnneeUniv(String value) {
		prevSelectedAnneeUniv = selectedAnneeUniv;
		selectedAnneeUniv = value;
		selectedAnneeUnivTS = DateCtrlConges.dateDebutAnneePourStrPeriodeAnnee(selectedAnneeUniv);
		if (prevSelectedAnneeUniv != null && !prevSelectedAnneeUniv.equals(selectedAnneeUniv)) {
			leMoisSelectionne = null;
			laSemaineDeLAnneeSelectionnee = null;
			lesMois = null;
		}
		resetDgAffectationAnnuelle();
	}

	/**
	 * raz des echelles selon les parametres
	 */
	public void appendToResponse(WOResponse response, WOContext context) {

		// effacer le cache
		dicoPresence = new NSMutableDictionary();

		if (voirJourneeComplete) {
			// de 0h00 a 24h00
			nbItemEchelle = 24;
			minutesEchelleInitales = MINUTES_DEBUT_JOURNEE_COMPLETE;
			minutesEchelle = minutesEchelleInitales;
			tailleGraph = MAX_TAILLE_GRAPH;
		} else {
			// de 7h00 a 19h00
			nbItemEchelle = 12;
			minutesEchelleInitales = MINUTES_DEBUT_JOURNEE_PARTIELLE;
			minutesEchelle = minutesEchelleInitales;
			tailleGraph = MAX_TAILLE_GRAPH / 2;
		}
		nbItemRegle = nbItemEchelle + 1;
		super.appendToResponse(response, context);
		// le texte de la css pour les 20 minutes de pause
		if (isVisuHoraire)
			addTextCss(response, textCssDivPause());
		// la css contenant le style pour le planning du service
		addLocalCss(response, "css/Service.css");
	}

	/**
	 * Clic sur le bouton filtrer pour ne conserver que les personnes
	 * selectionnees
	 */
	public WOComponent filtrer() {
		WORequest request = context().request();
		NSDictionary formValues = request.formValues();
		NSArray formValuesKeys = formValues.allKeys();

		recsFilteredAffAnns = new NSArray();
		for (int i = 0; i < formValuesKeys.count(); i++) {
			String aFormValuesKey = (String) formValuesKeys.objectAtIndex(i);

			// ignorer ce qu'il n'est pas un nombre => ne concerne donc pas un
			// planning

			try {
				int index = Integer.valueOf(aFormValuesKey).intValue();
				EOAffectationAnnuelle uneAffectationAnnuelle = (EOAffectationAnnuelle) dgAffectationAnnuelle().allObjects().objectAtIndex(index);
				recsFilteredAffAnns = recsFilteredAffAnns.arrayByAddingObject(uneAffectationAnnuelle);

			} catch (Exception e) {

			}

		}

		modeFilter = MODE_FILTER_APPLIED;
		resetDgAffectationAnnuelle();

		return neFaitRien();
	}

	public NSArray presencesHorairesP() {
		typePlanningEnCours = "P";
		if (dicoPresence.valueForKey(dicoPresenceKey()) == null) {
			dicoPresence.setObjectForKey(presencesHoraires(), dicoPresenceKey());
		}
		return (NSArray) dicoPresence.objectForKey(dicoPresenceKey());
	}

	public NSArray presencesHorairesR() {
		typePlanningEnCours = "R";
		if (dicoPresence.valueForKey(dicoPresenceKey()) == null) {
			dicoPresence.setObjectForKey(presencesHoraires(), dicoPresenceKey());
		}
		return (NSArray) dicoPresence.objectForKey(dicoPresenceKey());
	}

	/*
	 * la cles pour le cache de presence : - pour les presences a la demi journee
	 * : Elle est composee du numero d'individu et du type de planning - pour les
	 * precence a la
	 */
	private String dicoPresenceKey() {
		return uneAffectationAnnuelleDuService.individu().oid() + "_" + typePlanningEnCours;
	}

	// cache pour le nombre total d'objets dans les tableaux
	// presencesHorairesP/presencesHorairesR
	// utiliser dans le count de Repetition5 du .wod
	public Number presencesHorairesTotalMois;

	private NSArray presencesHoraires() {
		NSArray presencesHoraires = PrintCSV.presencesHorairesPourAffectation(
				uneAffectationAnnuelleDuService, typePlanningEnCours, leMoisSelectionne);
		presencesHorairesTotalMois = new Integer(presencesHoraires.count());
		return presencesHoraires;
	}

	public WOComponent changeMois() {
		leMoisSelectionne = leMois;
		return null;
	}

	/**
	 * Selection du mois par defaut. Si c'est la periode en cours, alors on prends
	 * Le mois en cours, sinon, on se place sur le debut de l'annee selectionnee
	 */
	public NSTimestamp leMoisSelectionne() {
		if (leMoisSelectionne == null) {
			if (DateCtrlConges.isSameDay(selectedAnneeUnivTS, DateCtrlConges.dateToDebutAnneeUniv(DateCtrlConges.now()))) {
				leMoisSelectionne = DateCtrlConges.dateToDebutMois(DateCtrlConges.now());
			} else {
				leMoisSelectionne = selectedAnneeUnivTS;
			}
		}
		return leMoisSelectionne;
	}

	/**
	 * Savoir si c'est le mois selectionne dans le menu
	 */
	public boolean isMoisEnCours() {
		return (leMois != null && DateCtrlConges.isSameDay(leMois, leMoisSelectionne()));
	}

	public String affectationAnnuelleDuServiceName() {
		return String.valueOf(indexUneAffectationAnnuelleDuService);
	}

	/**
	 * Appui sur le lien "TOUS" qui permet d'affiche la liste de toutes les
	 * affectations annuelles du service.
	 */
	public WOComponent annulerFiltrer() {
		modeFilter = MODE_FILTER_RELEASED;
		resetDgAffectationAnnuelle();
		return neFaitRien();
	}

	/**
	 * construction de la liste des mois d'une année universitaire (celle en
	 * cours)
	 */
	public NSArray lesMois() {
		if (lesMois == null) {
			NSTimestamp currentMois = DateCtrlConges.dateToDebutAnneeUniv(selectedAnneeUnivTS);
			NSTimestamp nextMoisSept = DateCtrlConges.dateToDebutAnneeUniv(selectedAnneeUnivTS).timestampByAddingGregorianUnits(1, 0, 0, 0, 0, 0);
			lesMois = new NSArray();
			while (!DateCtrlConges.isSameDay(currentMois, nextMoisSept)) {
				lesMois = lesMois.arrayByAddingObject(currentMois);
				currentMois = currentMois.timestampByAddingGregorianUnits(0, 1, 0, 0, 0, 0);
			}
		}
		return lesMois;
	}

	public String classAMDemiJ() {
		isAM = true;
		return classePourPresenceAMDemiJ(unePresenceHoraire);
	}

	public String classPMDemiJ() {
		isAM = false;
		return classePourPresencePMDemiJ(unePresenceHoraire);
	}

	public NSArray lesJours() {
		return lesJoursPourMois(leMoisSelectionne());
	}

	public NSArray lesJoursPourMois(NSTimestamp mois) {
		NSTimestamp firstDay = mois;// leMoisSelectionne();
																// //firstDayOfMonth(indexOfMonth);
		NSTimestamp lastDay = firstDay.timestampByAddingGregorianUnits(0, 1, -1, 0, 0, 0);
		lesJours = new NSArray();
		while (DateCtrl.isBeforeEq(firstDay, lastDay)) {
			lesJours = lesJours.arrayByAddingObject(firstDay);
			firstDay = firstDay.timestampByAddingGregorianUnits(0, 0, 1, 0, 0, 0);
		}

		return lesJours;
	}

	public WODisplayGroup dgAffectationAnnuelle() {
		if (dgAffectationAnnuelle == null) {
			dgAffectationAnnuelle = new WODisplayGroup();
			dgAffectationAnnuelle.setObjectArray(displayedAffectationAnnuelles());
			dgAffectationAnnuelle.setCurrentBatchIndex(0);
			dgAffectationAnnuelle.setNumberOfObjectsPerBatch(30);
		}
		return dgAffectationAnnuelle;
	}

	/**
	 * La liste des affectations reellement affichees sont celles dont il y a un
	 * planning ouvert sur le mois en cours.
	 */
	private NSArray displayedAffectationAnnuelles() {
		NSMutableDictionary bindings = new NSMutableDictionary();

		NSMutableArray responsabilites = new NSMutableArray();

		if (radioIdStructure == RADIO_ID_STRUCTURE_SERVICE) {
			// les plannings du service
			bindings.setObjectForKey(laSession.structuresDispoParNiveauSelection().getStructure(), "service");
			responsabilites.addObject(laSession.structuresDispoParNiveauSelection());
		} else if (radioIdStructure == RADIO_ID_STRUCTURE_COMPOSANTE) {
			// les plannings de la composante
			bindings.setObjectForKey(laSession.structuresDispoParNiveauSelection().getStructure().toComposante(), "composante");
			// on prend les responsabilites de toute la composante
			NSArray responsabilitesComposante = EOQualifier.filteredArrayWithQualifier(
					laSession.structuresDispoParNiveau(), CRIDataBus.newCondition(
							Responsabilite.COMPOSANTE_KEY + "=%@", new NSArray(laSession.structuresDispoParNiveauSelection().getComposante())));
			responsabilites.addObjectsFromArray(responsabilitesComposante);
		} else if (radioIdStructure == RADIO_ID_PLANNINGS_CONSULTABLES_PAR_MOI) {
			// tous les plannings visibles par la personne
			responsabilites.addObjectsFromArray(laSession.structuresDispoParNiveau());
		}

		bindings.setObjectForKey(selectedAnneeUniv, "annee");
		bindings.setObjectForKey(leMoisSelectionne(), "dateDebut");
		bindings.setObjectForKey(leMoisSelectionne().timestampByAddingGregorianUnits(0, 1, -1, 0, 0, 0), "dateFin");

		NSArray recsAllAffAnn = EOUtilities.objectsWithFetchSpecificationAndBindings(
				edc, EOAffectationAnnuelle.ENTITY_NAME,
				EOAffectationAnnuelle.AFFECTATIONS_ANNUELLES_POUR_MOIS_FETCH_SPEC, bindings);

		// on filtre les affectation selon les droits de l'individu sur le service
		recsAllAffAnn = EOAffectationAnnuelle.filteredAffectationsForResponsabilites(recsAllAffAnn, responsabilites);

		// affichage conditionne par le filtre
		NSArray recsDisplayedAffAnn = new NSArray();
		if (modeFilter == MODE_FILTER_APPLIED) {
			// on croise avec la selection
			for (int i = 0; i < recsFilteredAffAnns.count(); i++) {
				EOAffectationAnnuelle aFilteredAffAnn = (EOAffectationAnnuelle) recsFilteredAffAnns.objectAtIndex(i);
				if (recsAllAffAnn.containsObject(aFilteredAffAnn)) {
					recsDisplayedAffAnn = recsDisplayedAffAnn.arrayByAddingObject(aFilteredAffAnn);
				}
			}
		} else {
			recsDisplayedAffAnn = recsAllAffAnn;
		}

		// vurer les doublons
		recsDisplayedAffAnn = ArrayCtrl.removeDoublons(recsDisplayedAffAnn);

		// on fait un petit classement alphabetique la dessus
		recsDisplayedAffAnn = EOSortOrdering.sortedArrayUsingKeyOrderArray(
				recsDisplayedAffAnn, EOAffectationAnnuelle.SORT_INDIVIDU);

		return recsDisplayedAffAnn;
	}

	public WOComponent detaillerPlanning() {
		// laSession.preparerPlanningForIndividu(uneAffectationAnnuelleDuService.individu());
		laSession.preparerPlanningForAffectationAnnuelle(uneAffectationAnnuelleDuService);
		PagePlannings nextPage = (PagePlannings) laSession.getSavedPageWithName(PagePlannings.class.getName());
		nextPage.initialiserVisualisation();
		return nextPage;
	}

	public String numeroLesJoursItem() {
		String numeroLesJoursItem = "";

		GregorianCalendar lesJoursItemGC = new GregorianCalendar();
		lesJoursItemGC.setTime(lesJoursItem);

		int indexJourEnCours = lesJoursItemGC.get(Calendar.DAY_OF_WEEK);
		if (indexJourEnCours < 2)
			indexJourEnCours += 5;
		else
			indexJourEnCours -= 2;

		numeroLesJoursItem += lesJoursLibelle.objectAtIndex(indexJourEnCours);
		numeroLesJoursItem += String.valueOf(lesJoursItemGC.get(GregorianCalendar.DAY_OF_MONTH));
		return numeroLesJoursItem;
	}

	// cache des tailles de cellule pour la vue journaliere
	private Integer _widthAvtAMP, _widthAvtAMR, _widthAMP, _widthAMR, _widthMidiP,
			_widthMidiR, _widthPMP, _widthPMR, _widthAprPMP, _widthAprPMR;

	public int widthAvtAMP() {
		if (_widthAvtAMP == null) {
			typePlanningEnCours = "P";
			_widthAvtAMP = new Integer(widthAvtAM());
		}
		return _widthAvtAMP.intValue();
	}

	public int widthAvtAMR() {
		if (_widthAvtAMR == null) {
			typePlanningEnCours = "R";
			_widthAvtAMR = new Integer(widthAvtAM());
		}
		return _widthAvtAMR.intValue();
	}

	// affichage des recouvrement des horaires journaliers
	private int widthAvtAM() {
		EOPlanningHebdomadaire planningHebdo = uneAffectationAnnuelleDuService.planningHebdo(
				typePlanningEnCours, laSemaineDeLAnneeSelectionnee());
		if (planningHebdo != null) {
			EOHoraire horaire = planningHebdo.horaire();
			if (horaire != null) {
				int diff = horaire.minutesAtIndexDayAndPosInDay(indexJourEnCours, 0) - minutesEchelleInitales;
				if (diff > 0)
					return diff;
			}
		}
		return 0;
	}

	public int widthAMP() {
		if (_widthAMP == null) {
			typePlanningEnCours = "P";
			_widthAMP = new Integer(widthAM());
		}
		return _widthAMP.intValue();
	}

	public int widthAMR() {
		if (_widthAMR == null) {
			typePlanningEnCours = "R";
			_widthAMR = new Integer(widthAM());
		}
		return _widthAMR.intValue();
	}

	public int widthAM() {
		EOPlanningHebdomadaire planningHebdo = uneAffectationAnnuelleDuService.planningHebdo(
				typePlanningEnCours, laSemaineDeLAnneeSelectionnee());
		if (planningHebdo != null) {
			EOHoraire horaire = planningHebdo.horaire();
			if (horaire != null) {
				int diff = horaire.minutesAtIndexDayAndPosInDay(indexJourEnCours, 1) -
						horaire.minutesAtIndexDayAndPosInDay(indexJourEnCours, 0);
				if (diff > 0)
					return diff;
			}
		}
		return 0;
	}

	public int widthMidiP() {
		if (_widthMidiP == null) {
			typePlanningEnCours = "P";
			_widthMidiP = new Integer(widthMidi());
		}
		return _widthMidiP.intValue();
	}

	public int widthMidiR() {
		if (_widthMidiR == null) {
			typePlanningEnCours = "R";
			_widthMidiR = new Integer(widthMidi());
		}
		return _widthMidiR.intValue();
	}

	public int widthMidi() {
		EOPlanningHebdomadaire planningHebdo = uneAffectationAnnuelleDuService.planningHebdo(
				typePlanningEnCours, laSemaineDeLAnneeSelectionnee());
		if (planningHebdo != null) {
			EOHoraire horaire = planningHebdo.horaire();
			if (horaire != null) {
				int debut = horaire.minutesAtIndexDayAndPosInDay(indexJourEnCours, 1);
				int fin = horaire.minutesAtIndexDayAndPosInDay(indexJourEnCours, 2);
				int diff = fin - debut;
				// si pas d'horaire le matin, on oublie pas le decalage
				if (debut == 0)
					diff -= minutesEchelleInitales;
				if (diff > 0)
					return diff;
			}
		}
		return 0;
	}

	public int widthPMP() {
		if (_widthPMP == null) {
			typePlanningEnCours = "P";
			_widthPMP = new Integer(widthPM());
		}
		return _widthPMP.intValue();
	}

	public int widthPMR() {
		if (_widthPMR == null) {
			typePlanningEnCours = "R";
			_widthPMR = new Integer(widthPM());
		}
		return _widthPMR.intValue();
	}

	public int widthPM() {
		EOPlanningHebdomadaire planningHebdo = uneAffectationAnnuelleDuService.planningHebdo(typePlanningEnCours, laSemaineDeLAnneeSelectionnee());
		if (planningHebdo != null) {
			EOHoraire horaire = planningHebdo.horaire();
			if (horaire != null) {
				int diff = horaire.minutesAtIndexDayAndPosInDay(indexJourEnCours, 3) - horaire.minutesAtIndexDayAndPosInDay(indexJourEnCours, 2);
				if (diff > 0)
					return diff;
			}
		}
		return 0;
	}

	public int widthAprPMP() {
		if (_widthAprPMP == null) {
			typePlanningEnCours = "P";
			_widthAprPMP = new Integer(widthAprPM());
		}
		return _widthAprPMP.intValue();
	}

	public int widthAprPMR() {
		if (_widthAprPMR == null) {
			typePlanningEnCours = "R";
			_widthAprPMR = new Integer(widthAprPM());
		}
		return _widthAprPMR.intValue();
	}

	private int widthAprPM() {
		EOPlanningHebdomadaire planningHebdo = uneAffectationAnnuelleDuService.planningHebdo(typePlanningEnCours, laSemaineDeLAnneeSelectionnee());
		if (planningHebdo != null) {
			EOHoraire horaire = planningHebdo.horaire();
			if (horaire != null) {
				int diff = tailleGraph - (widthAvtAM() + widthAM() + widthMidi() + widthPM());
				if (diff > 0)
					return diff;
			}
		}
		return 0;
	}

	public String heuresEchelle() {
		String heure = TimeCtrl.stringForMinutes(minutesEchelle % 1440);
		return heure;
	}

	public String demiHeuresEchelle() {
		String heure = TimeCtrl.stringForMinutes((minutesEchelle + 30) % 1440);
		minutesEchelle += 60;
		return heure;
	}

	/**
	 * toutes les semaines entre le debut et la fin de l'année
	 * 
	 * @return
	 */
	public NSArray lesSemainesDeLAnnee() {
		if (lesSemainesDeLAnnee == null) {
			lesSemainesDeLAnnee = new NSMutableArray();
			// on prends le lundi suivant
			// NSTimestamp lundiEnCours =
			// DateCtrlConges.toLundi(selectedAnneeUnivTS.timestampByAddingGregorianUnits(0,
			// 0, 7, 0, 0, 0));
			// meuh non on prend le lundi en cours !
			NSTimestamp lundiEnCours = DateCtrlConges.toLundi(selectedAnneeUnivTS);
			// on prends tous les lundi qui sont avant la fin de l'année
			while (DateCtrl.isBeforeEq(lundiEnCours, laSession.finAnnee())) {
				lesSemainesDeLAnnee.addObject(lundiEnCours);
				lundiEnCours = lundiEnCours.timestampByAddingGregorianUnits(0, 0, 7, 0, 0, 0);
			}
			// le dernier jour a-t-il deja été compte ?
			if (lesSemainesDeLAnnee.containsObject(laSession.finAnnee()) == false) {
				lesSemainesDeLAnnee.addObject(laSession.finAnnee());
			}
		}
		return lesSemainesDeLAnnee.immutableClone();
	}

	/**
	 * Selection de la semaine par defaut. Si c'est la periode en cours, alors on
	 * prends la semaine en cours, sinon, on se place sur le debut de l'annee
	 * selectionnee
	 */
	public NSTimestamp laSemaineDeLAnneeSelectionnee() {
		if (laSemaineDeLAnneeSelectionnee == null) {
			if (DateCtrlConges.isSameDay(selectedAnneeUnivTS, DateCtrlConges.dateToDebutAnneeUniv(DateCtrlConges.now())))
				laSemaineDeLAnneeSelectionnee = DateCtrlConges.toLundi(laSession.dateRef());
			else
				laSemaineDeLAnneeSelectionnee = DateCtrlConges.toLundi(selectedAnneeUnivTS);
		}
		return TimeCtrl.dateToMinuit(laSemaineDeLAnneeSelectionnee);
	}

	// NAVIGATION

	public WOComponent goPageService() {
		isVisuHoraire = false;
		return null;
	}

	public WOComponent goPageHoraire() {
		isVisuHoraire = true;
		return null;
	}

	public WOComponent goJourLibelleLong() {
		indexJourEnCours = lesJoursLibelleLong.indexOfIdenticalObject(unJourLibelleLong);
		return null;
	}

	// DISPLAY

	public String displayUneSemaineDeLAnnee() {
		return DateCtrl.dateToString(uneSemaineDeLAnnee) + " -> " + DateCtrl.dateToString(uneSemaineDeLAnnee.timestampByAddingGregorianUnits(0, 0, 6, 0, 0, 0))
				+ " (n° " + DateCtrlConges.weekNumber(uneSemaineDeLAnnee) + ")";
	}

	public String classTabMenu() {
		String classTabMenu = "tab";
		if (lesJoursLibelleLong.indexOfIdenticalObject(unJourLibelleLong) == indexJourEnCours || isMoisEnCours()) {
			classTabMenu = "selectedTab";
		}
		return classTabMenu;
	}

	public String classeAMP() {
		typePlanningEnCours = "P";
		return classeAM();
	}

	public String classeAMR() {
		typePlanningEnCours = "R";
		return classeAM();
	}

	private String classeAM() {
		if (dicoPresence.objectForKey(dicoPresenceKey()) == null) {
			NSArray presenceJournaliere = uneAffectationAnnuelleDuService.presenceJournaliere(
					typePlanningEnCours, laSemaineDeLAnneeSelectionnee()
							.timestampByAddingGregorianUnits(0, 0, indexJourEnCours, 0, 0, 0));
			String bgColorAM = classeNonTravail();
			String presence = ((String) presenceJournaliere.objectAtIndex(0)).substring(0, 1);
			if (presence.equals(ConstsOccupation.PRESENCE_TRAVAIL)) {
				bgColorAM = classeTravail();
			} else if (presence.equals(ConstsOccupation.PRESENCE_OCCUPATION_DEMI_JOURNEE_VALIDEE)) {
				bgColorAM = classeAbsence();
			} else if (presence.equals(ConstsOccupation.PRESENCE_OCCUPATION_DEMI_JOURNEE_EN_COURS_DE_VALIDATION)) {
				bgColorAM = classeAbsenceEnCoursVal();
			}
			dicoPresence.setObjectForKey(bgColorAM, dicoPresenceKey());
		}
		return (String) dicoPresence.objectForKey(dicoPresenceKey());
	}

	public String classePMP() {
		typePlanningEnCours = "P";
		return classePM();
	}

	public String classePMR() {
		typePlanningEnCours = "R";
		return classePM();
	}

	private String classePM() {
		if (dicoPresence.objectForKey(dicoPresenceKey()) == null) {
			NSArray presenceJournaliere = uneAffectationAnnuelleDuService.presenceJournaliere(typePlanningEnCours, laSemaineDeLAnneeSelectionnee()
					.timestampByAddingGregorianUnits(0, 0, indexJourEnCours, 0, 0, 0));
			String bgColorPM = classeNonTravail();
			String presence = ((String) presenceJournaliere.objectAtIndex(0)).substring(1);
			if (presence.equals(ConstsOccupation.PRESENCE_TRAVAIL)) {
				bgColorPM = classeTravail();
			} else if (presence.equals(ConstsOccupation.PRESENCE_OCCUPATION_DEMI_JOURNEE_VALIDEE)) {
				bgColorPM = classeAbsence();
			} else if (presence.equals(ConstsOccupation.PRESENCE_OCCUPATION_DEMI_JOURNEE_EN_COURS_DE_VALIDATION)) {
				bgColorPM = classeAbsenceEnCoursVal();
			}
			dicoPresence.setObjectForKey(bgColorPM, dicoPresenceKey());
		}
		return (String) dicoPresence.objectForKey(dicoPresenceKey());

	}

	public WOComponent neFaitRien() {
		return null;
	}

	private String classePourPresenceAMDemiJ(String unePresence) {
		String bgColorAM = classeNonTravail();
		String presence = unePresence.substring(0, 1);
		if (presence.equals(ConstsOccupation.PRESENCE_TRAVAIL)) {
			bgColorAM = classeTravail();
		} else if (presence.equals(ConstsOccupation.PRESENCE_OCCUPATION_DEMI_JOURNEE_VALIDEE)) {
			bgColorAM = classeAbsence();
		} else if (presence.equals(ConstsOccupation.PRESENCE_OCCUPATION_DEMI_JOURNEE_EN_COURS_DE_VALIDATION)) {
			bgColorAM = classeAbsenceEnCoursVal();
		} else if (presence.equals(ConstsOccupation.PRESENCE_OCCUPATION_MINUTE_VALIDEE)) {
			bgColorAM = classeAbsenceMinute();
		} else if (presence.equals(ConstsOccupation.PRESENCE_OCCUPATION_MINUTE_EN_COURS_DE_VALIDATION)) {
			bgColorAM = classeAbsenceMinuteeEnCoursVal();
		}
		return bgColorAM;
	}

	private String classePourPresencePMDemiJ(String unePresence) {
		String bgColorPM = classeNonTravail();
		String presence = unePresence.substring(1);

		if (presence.equals(ConstsOccupation.PRESENCE_TRAVAIL)) {
			bgColorPM = classeTravail();
		} else if (presence.equals(ConstsOccupation.PRESENCE_OCCUPATION_DEMI_JOURNEE_VALIDEE)) {
			bgColorPM = classeAbsence();
		} else if (presence.equals(ConstsOccupation.PRESENCE_OCCUPATION_DEMI_JOURNEE_EN_COURS_DE_VALIDATION)) {
			bgColorPM = classeAbsenceEnCoursVal();
		} else if (presence.equals(ConstsOccupation.PRESENCE_OCCUPATION_MINUTE_VALIDEE)) {
			bgColorPM = classeAbsenceMinute();
		} else if (presence.equals(ConstsOccupation.PRESENCE_OCCUPATION_MINUTE_EN_COURS_DE_VALIDATION)) {
			bgColorPM = classeAbsenceMinuteeEnCoursVal();
		}
		return bgColorPM;
	}

	// style selon le type de planning en cours
	// en visu mensuelle on tient compte si c'est le matin ou pas
	// construction : <prefix> + <type_planning> [+<AM|PM>]

	private String classeAbsence() {
		String prefix = (isVisuHoraire ? "divHeb" : "divServ");
		String suffix = (isVisuHoraire ? "" : isAM ? ConstsOccupation.OCC_MATIN : ConstsOccupation.OCC_APREM);
		return prefix + "A" + typePlanningEnCours + suffix;
	}

	private String classeAbsenceMinute() {
		String prefix = (isVisuHoraire ? "divHeb" : "divServ");
		String suffix = (isVisuHoraire ? "" : isAM ? ConstsOccupation.OCC_MATIN : ConstsOccupation.OCC_APREM);
		return prefix + "CC" + typePlanningEnCours + suffix;
	}

	private String classeAbsenceEnCoursVal() {
		String prefix = (isVisuHoraire ? "divHeb" : "divServ");
		String suffix = (isVisuHoraire ? "" : isAM ? ConstsOccupation.OCC_MATIN : ConstsOccupation.OCC_APREM);
		return prefix + "AV" + typePlanningEnCours + suffix;
	}

	private String classeAbsenceMinuteeEnCoursVal() {
		String prefix = (isVisuHoraire ? "divHeb" : "divServ");
		String suffix = (isVisuHoraire ? "" : isAM ? ConstsOccupation.OCC_MATIN : ConstsOccupation.OCC_APREM);
		return prefix + "CCV" + typePlanningEnCours + suffix;
	}

	private String classeTravail() {
		String prefix = (isVisuHoraire ? "divHeb" : "divServ");
		String suffix = (isVisuHoraire ? "" : isAM ? ConstsOccupation.OCC_MATIN : ConstsOccupation.OCC_APREM);
		return prefix + "T" + typePlanningEnCours + suffix;
	}

	public String classeNonTravail() {
		String suffix = (isVisuHoraire ? "" : isAM ? ConstsOccupation.OCC_MATIN : ConstsOccupation.OCC_APREM);
		return (isVisuHoraire ? "divHeb" : "divServ") + "NT" + typePlanningEnCours + suffix;
	}

	/**
	 * override du setter pour raz des caches
	 * 
	 * @param value
	 */
	public void setUneAffectationAnnuelleDuService(EOAffectationAnnuelle value) {
		uneAffectationAnnuelleDuService = value;
		// raz cache
		_widthAvtAMP = _widthAvtAMR = _widthAMP = _widthAMR = _widthMidiP =
				_widthMidiR = _widthPMP = _widthPMR = _widthAprPMP = _widthAprPMR = null;
	}

	// impressions

	/**
	 * Classe controleur pour l'impression du planning de service en couleurs
	 */
	public class PdfBoxPlanningCouleurCtrl extends CngPdfBoxCtrl {
		public PdfBoxPlanningCouleurCtrl(Class aGenericSixPrintClass, EOEditingContext anEc) {
			super(aGenericSixPrintClass, anEc);
		}

		public NSDictionary buildDico() {
			return printDemiJournees(true);
		}

		public String fileName() {
			NSTimestamp leMoisSuivant = leMoisSelectionne.timestampByAddingGregorianUnits(0, 1, 0, 0, 0, 0);
			return "Plannings2MoisCouleur_" +
					StringCtrl.toBasicString(
							/*
							 * radioIdStructure == RADIO_ID_STRUCTURE_SERVICE ?
							 * laSession.structuresDispoParNiveauSelection
							 * ().getStructure().libelleCourt() :
							 * laSession.structuresDispoParNiveauSelection
							 * ().getStructure().toComposante().libelleCourt()) +
							 */
							getTitreForRadioStructureSelection(laSession.structuresDispoParNiveauSelection().getStructure(), false)) +
					"_" + StringCtrl.toBasicString(DateCtrl.dateToString(leMoisSelectionne, "%B")) + "_" + DateCtrl.dateToString(leMoisSelectionne, "%Y") +
					"_" + StringCtrl.toBasicString(DateCtrl.dateToString(leMoisSuivant, "%B")) + "_" + DateCtrl.dateToString(leMoisSuivant, "%Y");

		}

	}

	/** */
	public PdfBoxPlanningCouleurCtrl ctrlPlanningCouleur() {
		return new PdfBoxPlanningCouleurCtrl(PrintServiceDemiJournees.class, edc);
	}

	/**
	 * Classe controleur pour l'impression du planning de service en noir et blanc
	 */
	public class PdfBoxPlanningNbCtrl extends CngPdfBoxCtrl {
		public PdfBoxPlanningNbCtrl(Class aGenericSixPrintClass, EOEditingContext anEc) {
			super(aGenericSixPrintClass, anEc);
		}

		public NSDictionary buildDico() {
			return printDemiJournees(false);
		}

		public String fileName() {
			NSTimestamp leMoisSuivant = leMoisSelectionne.timestampByAddingGregorianUnits(0, 1, 0, 0, 0, 0);
			return "Plannings2MoisNb_" +
					StringCtrl.toBasicString(
							/*
							 * radioIdStructure == RADIO_ID_STRUCTURE_SERVICE ?
							 * laSession.structuresDispoParNiveauSelection
							 * ().getStructure().libelleCourt() :
							 * laSession.structuresDispoParNiveauSelection
							 * ().getStructure().toComposante().libelleCourt()) +
							 */
							getTitreForRadioStructureSelection(laSession.structuresDispoParNiveauSelection().getStructure(), false)) +
					"_" + StringCtrl.toBasicString(DateCtrl.dateToString(leMoisSelectionne, "%B")) + "_" + DateCtrl.dateToString(leMoisSelectionne, "%Y") +
					"_" + StringCtrl.toBasicString(DateCtrl.dateToString(leMoisSuivant, "%B")) + "_" + DateCtrl.dateToString(leMoisSuivant, "%Y");

		}
	}

	public PdfBoxPlanningNbCtrl ctrlPlanningNb() {
		return new PdfBoxPlanningNbCtrl(PrintServiceDemiJournees.class, edc);
	}

	/**
	 * impression : remplissage d un dico de donnees - le libelle du service - un
	 * tableau contenant n mois - un tableau contenant n tableaux des jours du
	 * mois - un tableau contenant p individus - un tableau contenant p tableaux
	 * de n tableaux des couleurs HTML de chaque demi journees
	 */
	private NSDictionary printDemiJournees(boolean enCouleur) {

		// recadrage des mois
		if (DateCtrlConges.isSameDay(leMoisSelectionne(), (NSTimestamp) lesMois().lastObject())) {
			leMoisSelectionne = leMoisSelectionne.timestampByAddingGregorianUnits(0, -1, 0, 0, 0, 0);
		}
		NSArray lesMois = new NSArray(new NSTimestamp[] {
				leMoisSelectionne(), leMoisSelectionne().timestampByAddingGregorianUnits(0, 1, 0, 0, 0, 0) });

		NSMutableDictionary dico = new NSMutableDictionary();

		// le service
		dico.setObjectForKey(
				/*
				 * radioIdStructure == RADIO_ID_STRUCTURE_SERVICE ?
				 * laSession.structuresDispoParNiveauSelection
				 * ().getStructure().libelleCourt() :
				 * laSession.structuresDispoParNiveauSelection
				 * ().getStructure().toComposante().libelleCourt(),
				 */
				getTitreForRadioStructureSelection(laSession.structuresDispoParNiveauSelection().getStructure(), false),
				"leService");

		// les mois
		dico.setObjectForKey(lesMois, "lesMois");

		// les jours
		NSArray lesJoursDesMois = new NSArray();
		lesJoursDesMois = lesJoursDesMois.arrayByAddingObject(lesJoursPourMois(leMoisSelectionne()));
		lesJoursDesMois = lesJoursDesMois.arrayByAddingObject(lesJoursPourMois(leMoisSelectionne().timestampByAddingGregorianUnits(0, 1, 0, 0, 0, 0)));
		dico.setObjectForKey(lesJoursDesMois, "lesJoursDesMois");

		// les individus
		// NSArray recsAffAnn = displayedAffectationAnnuelles();
		NSArray recsAffAnn = dgAffectationAnnuelle().displayedObjects();
		dico.setObjectForKey(recsAffAnn.valueForKeyPath("individu.nomComplet"), "lesIndividus");

		// le type d'impression
		dico.setObjectForKey(new Boolean(enCouleur), "enCouleur");

		// les couleurs
		NSArray couleurs = new NSArray();
		couleurs = couleurs.arrayByAddingObject("white");// classeNonTravail());
		typePlanningEnCours = "R";
		couleurs = couleurs.arrayByAddingObject("blue");// classeTravail());
		couleurs = couleurs.arrayByAddingObject("deeppink");// classeAbsence());
		typePlanningEnCours = "P";
		couleurs = couleurs.arrayByAddingObject("cornflowerblue");// classeTravail());
		couleurs = couleurs.arrayByAddingObject("plum");// classeAbsence());
		couleurs = couleurs.arrayByAddingObject("yellow");// classeAbsenceEnCoursVal());
		dico.setObjectForKey(couleurs, "lesCouleurs");

		// les couleurs
		NSArray lesCouleursDesIndividus = new NSArray();
		for (int i = 0; i < recsAffAnn.count(); i++) {
			// pour tous les individus
			EOAffectationAnnuelle uneAffAnn = (EOAffectationAnnuelle) recsAffAnn.objectAtIndex(i);
			NSArray lesCouleursPEtR2 = new NSArray();
			for (int index = 0; index < lesMois.count(); index++) {
				// par mois
				NSTimestamp moisEnCours = (NSTimestamp) lesMois.objectAtIndex(index);
				NSArray lesCouleursDuMois = new NSArray();
				for (int j = 0; j < Planning.TYPES_PLANNINGS_VISIBLES.count(); j++) {
					// planning reel puis previsionnel
					typePlanningEnCours = (String) Planning.TYPES_PLANNINGS_VISIBLES.objectAtIndex(j);
					NSArray presencesHorairesPourAffAnn = PrintCSV.presencesHorairesPourAffectation(uneAffAnn, typePlanningEnCours, moisEnCours);
					NSArray lesCodesCouleurs = new NSArray();
					for (int k = 0; k < presencesHorairesPourAffAnn.count(); k++) {
						// etats des demi journees pour le mois
						String unePresence = (String) presencesHorairesPourAffAnn.objectAtIndex(k);
						lesCodesCouleurs = lesCodesCouleurs.arrayByAddingObject(
								PrintCSV.codePourPresenceAM(unePresence, true));
						lesCodesCouleurs = lesCodesCouleurs.arrayByAddingObject(
								PrintCSV.codePourPresencePM(unePresence, true));
					}

					lesCouleursDuMois = lesCouleursDuMois.arrayByAddingObject(lesCodesCouleurs);
				}
				lesCouleursPEtR2 = lesCouleursPEtR2.arrayByAddingObject(lesCouleursDuMois);
			}
			lesCouleursDesIndividus = lesCouleursDesIndividus.arrayByAddingObject(lesCouleursPEtR2);
		}

		dico.setObjectForKey(new NSArray(lesCouleursDesIndividus), "lesCodesCouleurs");

		// URL du logo
		dico.setObjectForKey(app.mainLogoUrl(), ConstsPrint.XML_KEY_MAIN_LOGO_URL);

		return dico;
	}

	/**
	 * Impression des horaires de tous les agents du service pour l'annee
	 * universitaire choisie.
	 */
	public class PdfBoxHorairesCtrl extends CngPdfBoxCtrl {

		public PdfBoxHorairesCtrl(Class aGenericSixPrintClass, EOEditingContext anEc) {
			super(aGenericSixPrintClass, anEc);
		}

		public NSDictionary buildDico() {
			NSMutableDictionary dico = new NSMutableDictionary();
			// EOAffectationAnnuelle anAffAnn = (EOAffectationAnnuelle)
			// displayedAffectationAnnuelles().lastObject();
			EOAffectationAnnuelle anAffAnn = (EOAffectationAnnuelle) dgAffectationAnnuelle().displayedObjects().lastObject();
			dico.setObjectForKey(anAffAnn.annee(), "anneeUniv");
			dico.setObjectForKey(
					/*
					 * radioIdStructure == RADIO_ID_STRUCTURE_SERVICE ?
					 * anAffAnn.structure().libelleLong() :
					 * anAffAnn.structure().toComposante().libelleLong(),
					 */
					getTitreForRadioStructureSelection(anAffAnn.structure(), true),
					"service");
			// dico.setObjectForKey(displayedAffectationAnnuelles(),
			// "listAffectationAnnuelle");
			dico.setObjectForKey(dgAffectationAnnuelle().displayedObjects(), "listAffectationAnnuelle");
			dico.setObjectForKey(
					DateCtrlConges.dateToString(DateCtrlConges.now()), "dateImpression");
			// URL du logo
			dico.setObjectForKey(app.mainLogoUrl(), ConstsPrint.XML_KEY_MAIN_LOGO_URL);
			return dico;
		}

		public String fileName() {
			return "Horaires_" +
					StringCtrl.toBasicString(laSession.structuresDispoParNiveauSelection().getStructure().libelleCourt()) + "_" +
					StringCtrl.replace(DateCtrlConges.anneeUnivForDate(leMoisSelectionne), "/", "_");
		}

	}

	/** */
	public PdfBoxHorairesCtrl ctrlHoraires() {
		return new PdfBoxHorairesCtrl(PrintHoraires.class, edc);
	}

	/**
	 * Alternance de couleur pour le fond de chaque agent
	 */
	public String classeDivIndividu() {
		return ((indexUneAffectationAnnuelleDuService % 2 == 0) ? "divLigneIndividuPair" : "divLigneIndividuImpair");
	}

	/**
	 * Le planning mensuel possede une largeur dynamique, selon le nombre de jours
	 * contenu. 179 + n*26
	 */
	public String styleDivPlanningMensuel() {
		return "width:" + (179 + 26 * lesJours().count()) + "px";
	}

	/**
	 * Le planning hebdoo depend de la fenetre a observer 12 heures ou 24 heures
	 * 
	 * @return
	 */
	public String styleDivPlanningHebdo() {
		return "width:" + (179 + tailleGraph) + "px";
	}

	// LES DIVS POUR LA PRESENCE JOURNALIERE

	public String styleDivReelAvtAM() {
		return "width:" + widthAvtAMR() + "px";
	}

	public String styleDivReelHorAM() {
		return "width:" + widthAMR() + "px";
	}

	public String styleDivReelMidi() {
		return "width:" + widthMidiR() + "px";
	}

	public String styleDivReelHorPM() {
		return "width:" + widthPMR() + "px;";
	}

	public String styleDivReelAprPM() {
		return "width:" + widthAprPMR() + "px";
	}

	public String styleDivPrevAvtAM() {
		return "width:" + widthAvtAMP() + "px";
	}

	public String styleDivPrevHorAM() {
		return "width:" + widthAMP() + "px";
	}

	public String styleDivPrevMidi() {
		return "width:" + widthMidiP() + "px";
	}

	public String styleDivPrevHorPM() {
		return "width:" + widthPMP() + "px";
	}

	public String styleDivPrevAprPM() {
		return "width:" + widthAprPMP() + "px";
	}

	// LA DIV POUR LA PAUSE DE 20 MINUTES

	/**
	 * Positionnement de la pause dans le planning hebdomadaire
	 */
	public String styleCssDivPause() {
		// construction de la cle en precisant que c'est pour la pause
		String key = dicoPresenceKey() + "P";
		if (dicoPresence.objectForKey(key) == null) {
			EOPlanningHebdomadaire planningHebdo = uneAffectationAnnuelleDuService.planningHebdo(
					typePlanningEnCours, laSemaineDeLAnneeSelectionnee());
			if (planningHebdo != null && planningHebdo.horaire() != null) {
				int pos = planningHebdo.horaire().minutesPauseAtIndexDayAndPosInDay(indexJourEnCours);
				if (pos > 0) {
					// bon la div se fout a 12:50, je sais pas pk, alors on fait avec ...
					dicoPresence.setObjectForKey("left:" + (pos - (12 * 60 + 50)) + "px", key);
				}
			}
			if (dicoPresence.objectForKey(key) == null)
				dicoPresence.setObjectForKey("display:none", key);
		}
		return (String) dicoPresence.objectForKey(key);
	}

	private String textCssDivPause;

	/**
	 * la div pour la pause RTT : sa taille depend de la duree de la pause de
	 * l'etablissement
	 */
	public String textCssDivPause() {
		if (textCssDivPause == null) {
			textCssDivPause = ".divPause {\n";
			if (isShowPause) {
				textCssDivPause += "height: 10px;\n";
				textCssDivPause += "width: " + (pauseDureeRtt - 2) + "px;\n";
				textCssDivPause += "top: 0px;\n";
				textCssDivPause += "background-color: white;\n";
				textCssDivPause += "border-left: 1px solid #000000;\n";
				textCssDivPause += "border-right: 1px solid #000000;\n";
				textCssDivPause += "filter:alpha(opacity=60);\n";
				textCssDivPause += "-moz-opacity:0.6;\n";
				textCssDivPause += "opacity: 0.6;\n";
			} else {
				textCssDivPause += "display:none;";
			}
			textCssDivPause += "}";
		}
		return textCssDivPause;
	}

	private static int pauseDureeRtt;

	// faut-il afficher la pause RTT
	public static boolean isShowPause;

	/**
	 * @see I_ClasseMetierNotifiableParametre
	 */
	public static void initStaticField(Parametre parametre) {
		if (parametre == Parametre.PARAM_PAUSE_RTT_DUREE) {
			pauseDureeRtt = TimeCtrl.getMinutes(parametre.getParamValueString());
		} else if (parametre == Parametre.PARAM_SHOW_PAUSE) {
			isShowPause = parametre.getParamValueBoolean().booleanValue();
		}
	}

	// une varaiable bidon pour ne plus avoir l'erreur sur
	// composant concernant les checkbox
	public Boolean fakeCheckAgent;

	// affichage du planning pour toute la composante

	/**
	 * Pour l'instant, on n'autorise que les administrateurs et drh de remonter
	 * jusqu'a la composante
	 */
	public boolean isShowRadioComposante() {
		boolean result = false;
		if (laSession.isAdministrateur() ||
				laSession.isDrh() ||
				laSession.cngUserInfo().isAdmComposanteForService(laSession.structuresDispoParNiveauSelection().getStructure()) ||
				laSession.cngUserInfo().isDrhComposanteForService(laSession.structuresDispoParNiveauSelection().getStructure())) {
			result = true;
		}
		return result;
	}

	/**
	 * les plannings visibles par la personne connectée - les admin / drh - ceux
	 * qui ont plus d'1 structure en droit cible
	 * 
	 * @return
	 */
	public boolean isShowRadioPlanningConsultablesParMoi() {
		boolean result = false;
		if (laSession.isAdministrateur() ||
				laSession.isDrh() ||
				laSession.structuresDispoParNiveau().count() > 1) {
			result = true;
		}
		return result;
	}

	/**
	 * Le libelle du service inspecte
	 * 
	 * @return
	 */
	public String strService() {
		try {
			return laSession.structuresDispoParNiveauSelection().getStructure().libelleCourt();
		} catch (Exception e) {
			return "<erreur>";
		}
	}

	/**
	 * Le libelle de la composante du service inspecte
	 * 
	 * @return
	 */
	public String strComposante() {
		try {
			return laSession.structuresDispoParNiveauSelection().getStructure().toComposante().libelleCourt();
		} catch (Exception e) {
			return "<erreur>";
		}
	}

	// affichage du statut du planning

	/**
	 * La couleur associee au statut
	 */
	public String getStyleHtmlColorPlanning() {
		String stylePrefix = "background-color: ";
		String color = "#FFFFFF";
		if (uneAffectationAnnuelleDuService.isPlanningValide()) {
			color = ConstsPlanning.HTML_COLOR_PLANNING_VALIDE;
		} else if (uneAffectationAnnuelleDuService.isPlanningEnCoursDeModification()) {
			color = ConstsPlanning.HTML_COLOR_PLANNING_EN_COURS_DE_MODIFICATION;
		} else if (uneAffectationAnnuelleDuService.isPlanningEnCoursDeValidation()) {
			color = ConstsPlanning.HTML_COLOR_PLANNING_EN_COURS_DE_VALIDATION;
		} else if (uneAffectationAnnuelleDuService.isPlanningNonValide()) {
			color = ConstsPlanning.HTML_COLOR_PLANNING_INVALIDE;
		}
		return stylePrefix + color;
	}

	/**
	 * Le libelle du statut
	 * 
	 * @return
	 */
	public String getHtmlLabelPlanning() {
		String label = "INCONNU";
		if (uneAffectationAnnuelleDuService.individu() == null) {
			LRLog.log("Planning en erreur : OID_AFF_ANN=" + uneAffectationAnnuelleDuService.oid());
		}
		String labelPrefix = "Le planning de " + uneAffectationAnnuelleDuService.individu().nomComplet() + " est ";
		if (uneAffectationAnnuelleDuService.isPlanningValide()) {
			label = ConstsPlanning.HTML_LABEL_PLANNING_VALIDE;
		} else if (uneAffectationAnnuelleDuService.isPlanningEnCoursDeModification()) {
			label = ConstsPlanning.HTML_LABEL_PLANNING_EN_COURS_DE_MODIFICATION;
		} else if (uneAffectationAnnuelleDuService.isPlanningEnCoursDeValidation()) {
			label = ConstsPlanning.HTML_LABEL_PLANNING_EN_COURS_DE_VALIDATION;
		} else if (uneAffectationAnnuelleDuService.isPlanningNonValide()) {
			label = ConstsPlanning.HTML_LABEL_PLANNING_INVALIDE;
		}
		return labelPrefix + label.toLowerCase();
	}

	// export CVS

	/**
	 * 
	 */
	public WOResponse printCsv() {
		if (dgAffectationAnnuelle().displayedObjects().count() > 0) {
			NSTimestamp debut = (NSTimestamp) lesMois().objectAtIndex(0);
			NSTimestamp fin = DateCtrlConges.dateToFinMois((NSTimestamp) lesMois().lastObject());
			return PrintCSV.printCsvPlanningPourPeriode(
					"export", debut, fin, dgAffectationAnnuelle().displayedObjects(), typePlanningEnCours);
		} else {
			return null;
		}
	}

	/**
	 * Transformer la valeur de l'affichage de la pause en variable de classe pour
	 * binding dans l'interface
	 */
	public boolean getIsShowPause() {
		return isShowPause;
	}

	/**
	 * Le titre a afficher dans les editions selon la selection de l'utilisateur :
	 * service, composante ou tous les plannings visible
	 * 
	 * @return
	 */
	private String getTitreForRadioStructureSelection(
			EOStructure structure, boolean isLibelleLong) {
		String titre = null;

		if (radioIdStructure == RADIO_ID_STRUCTURE_SERVICE) {
			titre = (isLibelleLong ? structure.libelleLong() : structure.libelleCourt());
		} else if (radioIdStructure == RADIO_ID_STRUCTURE_COMPOSANTE) {
			titre = (isLibelleLong ? structure.toComposante().libelleLong() : structure.toComposante().libelleCourt());
		} else if (radioIdStructure == RADIO_ID_PLANNINGS_CONSULTABLES_PAR_MOI) {
			titre = "Plannings consultables par " + cngUserInfo().nomEtPrenom();
		}

		return titre;
	}

	public final int getRadioIdStructure() {
		return radioIdStructure;
	}

	public final void setRadioIdStructure(int radioIdStructure) {
		this.radioIdStructure = radioIdStructure;
		resetDgAffectationAnnuelle();
	}

	/**
	 * 
	 * @return
	 */
	public boolean isMultipage() {
		return dgAffectationAnnuelle().allObjects().count() > dgAffectationAnnuelle().numberOfObjectsPerBatch();
	}

	/**
	 * On interdit le filtrage s'il y plus d'une page affichée
	 * 
	 * @return
	 */
	public boolean isFiltrageAutorise() {
		return !isMultipage();
	}

	/**
	 * 
	 * @return
	 */
	public boolean isDisabledChkIndividu() {
		return !isFiltrageAutorise();
	}

	/**
	 * L'infobulle sur l'individu, qui affiche son nom complet (nécéssaire pour
	 * les noms qui ne s'affiche pas complètement dans l'interface)
	 * 
	 * @return
	 */
	public String getTitreForNomIndividu() {
		String titre = "";

		titre += "D&eacute;tailler le planning de ";
		titre += uneAffectationAnnuelleDuService.individu().nomComplet();

		return titre;
	}

	public void setNumberOfObjectsSelected(Integer number) {
		dgAffectationAnnuelle().setNumberOfObjectsPerBatch(number.intValue());
	}
}